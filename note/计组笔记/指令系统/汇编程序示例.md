# 汇编程序
## 一、赋值语句
### （一）寄存器操作数赋值
> RISC-V寄存器功能表（简化版）
| Register Number | Purpose                      |
|:---------------:|------------------------------|
| x0              | Constant Zero                |
| x1              | Return Address               |
| x2              | Stack Pointer                |
| x5~x7           | Temporary Storage            |
| x10~x11         | Function Parameters/Return Value |
| x12~x17         | Function Parameters          |
| x18~x27         | Saved Registers (Flexible Use)|

所要操作的数据均存储于寄存器中，可以直接使用
Example:
> f = (g + h) - (m + n)
其中，f,g,h,m,n逐个存储于x18~x22中

~~~
add x5, x19, x20
add x6, x21, x22
sub x18, x5, x6
~~~
### （二）内存操作数赋值
#### 1. 数组
注意课本中数组的单位元素大小为8Byte，而RISCV的寻址单位是Byte
Example:
> A[12] = A[i] + A[0]
其中，A[]地址存储在x22，i存储在x23

~~~
// 第一种数组寻址：直接写出偏移量
ld x17, x22
// 第二种数组寻址：将索引左移3位(乘以8)后与基址相加得到偏移地址
slli x23, 3
add x24, x22, x23
ld x18, 0(x24)
add x19, x17, x18
sd x19, 96(x22)
~~~
#### 2.堆栈
堆栈存储在内存中，其中堆自底向上生长，栈**自顶向下**生长
代码示例等详情参照
## 二、分支结构
在严格的分支结构中，应当先写分支中不发生跳转的分支，这样可以避免先写的分支执行后由于顺序执行特点继续执行后写的分支。
分支语句中除了数据运算类指令和数据传送类指令外，还要用到流程控制类指令。
Example:
> if(i > j) i += j;
> else i -= j;
> 其中i,j存储在x17,x18中

~~~
      blt x18, x17, Label
      // 先写分支不发生跳转的分支
      sub x17, x17, x18
      // 后写分支跳转的分支
Label:add x17, x17, x18   
~~~
## 三、循环语句
一般选择“往回”（程序总体前进方向的反方向）跳转，利用**程序顺序执行的特点**自然地构成循环。
Example:
> long long int i = 0;
> for(; i < n; i++) {
>     if(nums[i] == k) break;
> }
> 其中i,n,k存放在x5,x6,x7

~~~
      la x18, nums      // 取数组首地址
      addi x5, x0, 0   
Label:bge x5, x6, Exit
      // i++
      addi x5, x5, 1
      // 将 nums[i] 存入x21
      slli x19, x5, 3
      add x20, x18, x19
      ld x21, 0(x20)
      beq x21, x7, Exit
      // 无条件跳转，实现循环
      jal x0, Label
Exit: // 后续的指令
~~~
## 四、函数及递归

Example:
>将如下的 C 代码中的函数 f 翻译转换成 RISC-V 汇编代码
要求：分别用 x12-x15 传递入口参数 a-d，并转移至 x18-x21；用 x10 传递出口参数。
int funct(int a, int b);
int f(int a, int b, int c, int d)
{ return funct(funct(a,b),c+d); }

~~~assembly
f: addi sp, sp, -32
// 用栈保存现场
 sw x18, 0(sp) 
 sw x19, 8(sp)
 sw x20, 16(sp) 
 sw x21, 24(sp)
// 转移赋值，接收输入数值
 add x18, x0, x12 
 add x19, x0, x13
 add x20, x0, x14 
 add x21, x0, x15
 addi sp, sp, -8 
 sw x1, 0(sp)
 jal x1, funct
 add x12, x0, x10
 add x5, x0, x20 
 add x5, x5, x21
 add x13, x0, x5 
 jal x1, funct
 lw x1, 0(sp) 
 addi sp, sp, 8
 lw x18, 0(sp) 
 lw x19, 8(sp)
 lw x20, 16(sp) 
 lw x21, 24(sp)
 addi sp, sp, 32 
 jalr x0, 0(x1)
~~~
