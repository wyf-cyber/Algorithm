# 二叉树(Binary Tree)

## 一、二叉树的定义
二叉树（Binary Tree）是一种常见的树状数据结构，每个节点最多有**两个子节点**：一个左子节点和一个右子节点。这种树形结构通常用于模拟自然界的层次关系。二叉树的节点包含**一个数据元素**和**两个指针**，分别指向左子节点和右子节点。

## 二、二叉树的基本性质
- 深度（Depth）：节点的深度是指从根节点到该节点的唯一路径的长度。根节点的深度为 0。
- 高度（Height）：节点的高度是指从该节点到叶子节点的最长路径的长度。叶子节点的高度为 0。
- 层次（Level）：节点的层次是指节点的深度加 1。
- 度（Degree）：节点的度是指其拥有的子节点数。二叉树的度最大为 2。
- 叶子节点（Leaf Node）：度为 0 的节点称为叶子节点。

## 三、二叉树的存储方式
1. 链式存储
在链式存储方式中，每个节点都由一个结构体或类表示，包含数据元素和两个指针，分别指向左子节点和右子节点。这种方式使用指针来连接节点，适用于动态变化的二叉树。
~~~cpp
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : data(x), left(nullptr), right(nullptr) {}
};
~~~
2. 顺序存储
在数组存储方式中，二叉树的节点按照特定顺序存储在数组中，通过数组索引进行访问。通常，使用数组存储方式来表示完全二叉树，因为它可以充分利用数组的连续存储特性，减少内存的浪费。
存储规律：
>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

## 四、二叉树的遍历方式
### 深度优先遍历
1. 前序遍历（Preorder Traversal）
前序遍历是先访问根节点（此处的根节点包括二叉树的根节点和每个子树的根节点），然后递归地前序遍历左子树，最后前序遍历右子树。简述为：**先根、再左、再右**
>在做题过程中，可以将先序遍历想象为，一个小人从一棵二叉树根节点为起点，沿着二叉树外沿，逆时针走一圈回到根节点，路上遇到的元素顺序，就是先序遍历的结果^[1]^

**题目示例：**[144.二叉树的前序遍历（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
~~~cpp
// 迭代法
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> s;
    if(root == NULL) return res;
    s.push(root);
    while(!s.empty()) {
        TreeNode* temp = s.top();
        s.pop();
        res.push_back(temp->val);
        // 由于栈先进后出，所以进栈顺序为先右后左
        if(temp->right) s.push(temp->right);
        if(temp->left) s.push(temp->left);
    }
    return res;
}
// 递归法
class Solution {
public:
    void preOrder(TreeNode* root, vector<int> &res) {
        if(root == NULL) return;
        res.push_back(root->val);
        preOrder(root->left, res);
        preOrder(root->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        preOrder(root, res);
        return res;
    }
};
~~~
2. 中序遍历（Inorder Traversal）
中序遍历是从根节点开始，先递归地中序遍历左子树，然后访问根节点，最后中序遍历右子树。中序遍历的结果是一个按照升序排列的序列。简述为：**先左、再根、再右**
>在做题过程中，可以将中序遍历想象为从最左边开始，把每个节点垂直投影到同一直线上，然后从左往右读值，所有节点落下形成的一行中的元素顺序，就是中序遍历的结果^[1]^

**题目示例：**[94.二叉树的中序遍历（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
~~~cpp
// 迭代法
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> s;
    // 先访问左子树，用指针做遍历找到搜索开始位置
    TreeNode* p = root;
    while(p != NULL || s.empty() != true) {
        if(p != NULL) {
            // 将p压栈，继续遍历p的左子树
            s.push(p);
            p = p->left;
        }else {
            // 左子树为空，开始逐个弹出栈中元素
            // 先读取当前所在子树的根节点，再搜索右子树
            p = s.top();
            s.pop();
            res.push_back(p->val);
            p = p->right;
        }
    }
        return res;
}
// 递归法 略
~~~
3. 后序遍历（Postorder Traversal）
后序遍历是从根节点开始，先递归地后序遍历左子树，然后递归地后序遍历右子树，最后访问根节点。简述为：**先左、再右、再根**
>在做题过程中，可以将后序遍历想象为：围着树的底部从左向右绕一圈，如果发现一剪刀就能剪下的元素（必须是一个元素，也就是元素要一个一个掉下来，不能一口气掉超过1个这样），就把它剪下来，掉下的元素按顺序组成的就是后序遍历了。^[1]^

**题目示例：**[145.二叉树的后序遍历（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
~~~cpp
// 迭代法
// 先仿照前序遍历的方法找出中右左（注意反转左右顺序），再反转获得的数组即可
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> s;
    if(root == NULL) return res;
    s.push(root);
    while(!s.empty()) {
        TreeNode* p = s.top();
        s.pop();
        res.push_back(p->val);
        // 注意调换左右顺序
        if(p->left) s.push(p->left);
        if(p->right) s.push(p->right); 
    }
    reverse(res.begin(), res.end());
    return res;
}
// 递归法 略
~~~
### 广度优先遍历
1. 层序遍历（Level-order Traversal）
层序遍历是从根节点开始自顶向下逐层遍历树的节点。在每一层中按照自左向右的顺序遍历。可以使用队列来实现层序遍历。

**题目示例：**[102.二叉树的层序遍历（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
~~~cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if(root == NULL) return res;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        // 由于一次只能找到左右节点，输出要求同一层节点存入同一个数组
        // 读取队列长度，每次while循环遍历一层元素并将下一层元素全部存入队列
        int size = q.size();
        vector<int> temp;
        for(int i = 0; i < size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            temp.push_back(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        res.push_back(temp);
    }
    return res;
}
~~~
## 五、二叉树的种类
1. 二叉搜索树（Binary Search Tree）
二叉搜索树是一种有序的二叉树，它的左子树中的所有节点的值都小于根节点的值，而右子树中的所有节点的值都大于根节点的值。这个特性使得二叉搜索树非常适合用二分法快速查找、插入和删除操作。
根据其定义在二叉搜索树中还存在以下关系：
>(1)若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
(2)若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
(3)它的左、右子树也分别为二叉排序树

2. 完全二叉树（Complete Binary Tree）
完全二叉树是一种二叉树，**除了最后一层**，所有其他层的节点都被完全填满，而且最后一层的节点都尽量靠左排列。若最底层为第 h 层（h从1开始），则该层可能包含 [1,  2^h-1^] 个节点。完全二叉树通常以数组形式存储，利用数组索引的特性可以方便地进行查找和插入操作。

3. 满二叉树（Full Binary Tree）
满二叉树是一种每个节点要么没有子节点（叶子节点），要么有两个子节点的二叉树。如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为n的满二叉树有2^n-1^个节点。

4. 平衡二叉树（Balanced Binary Tree）
平衡二叉树又被称为AVL（Adelson-Velsky and Landis）树，是一种高度平衡的二叉搜索树，它的左右子树的高度差不超过1。平衡二叉树的插入、删除和查找操作的时间复杂度都是 O(log n)，其中 n 是树中节点的个数。注意**空树**也是平衡二叉树。C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度都是O(logn)。


>引用文献：
[1]正弦定理.《数据结构——二叉树先序、中序、后序及层次四种遍历（C语言版）》.[原文链接](https://blog.csdn.net/chinesekobe/article/details/110874773?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169647218416800186572043%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169647218416800186572043&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-110874773-null-null.142^v94^chatsearchT3_1&utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86&spm=1018.2226.3001.4187).2023.10.5