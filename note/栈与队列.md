# 栈(stack)
## 一、栈的基本知识

### 1.什么是栈？
（1）栈是STL（C++标准库）中的一种数据结构
（2）栈中元素遵循“**先进后出**”(First In Last Out)原则，简称为**FILO**结构，也称为**后进先出表**
（3）栈对外提供push、pop等统一的接口，内部可以选择链表、数组、deque等数据结构实现。由于底层容器的选择**不影响**栈的使用，且使用者可以自由选择使用何种结构实现栈，因而栈具有**可插拔**的性质，在STL中被归类为“**容器适配器(container adapter)**”而不是容器。
~~~cpp
// 指定数组为底层容器的栈
std::stack<int, std::vector<int>> exp;
~~~

### 2.栈的组成
（1）由于栈只能对栈顶元素进行插入和删除操作，所以栈中不提供迭代器
（2）栈顶：允许元素进行插入和删除操作的位置
（3）栈底：与栈顶相对的另一端

### 3.栈的基本操作
（1）压栈（push）：将元素压入栈顶
（2）弹栈（pop）：将栈顶元素弹出
（3）求栈的大小（size）：求栈中元素的个数
（4）判断栈是否为空（empty）：若为空返回true，否则返回false
（5）获取栈顶的值（gettop()）：返回栈顶元素的值，但是不将该元素弹出
~~~cpp
// STL中栈主要的成员函数

int pop();                 // 弹出栈顶元素, 但不返回其值
bool push(T elm);          // 将元素压入栈顶
bool empty();              // 如果栈为空则返回true, 否则返回false;
int size();                // 返回栈中元素的个数
int top();                 // 返回栈顶元素, 但不删除该元素
~~~
### 4.如何使用STL中的栈
~~~cpp
#include <stack>
~~~

## 二、顺序栈&链栈
### 1.概念
- 顺序栈：是由顺序存储结构（数组等）实现的栈，数组首元素充当栈底，栈顶指针top指向栈顶元素，空栈中top = -1
- 链栈：是由链式存储结构实现的栈，使用头指针充当栈顶指针，尾指针指向栈底，空栈中只含头结点
### 2.特性
#### 顺序栈四要素
- 栈空条件：top = -1
- 栈满条件：top = MaxSize - 1
- 元素e进栈操作：top++， data[top] = e
- 元素e出栈操作：e = data[top], top--
#### 链栈四要素
- 栈空条件：head->next == NULL
- 栈满条件：只有在内存溢出时才会发生，一般不考虑
- 元素e进栈操作：使用头插法将包含该元素的节点s插入链栈
- 出栈操作：返回首节点的值并删除该节点

# 队列(queue)
## 一、队列的基本知识

### 1.什么是队列？
（1）队列是STL（C++标准库）中的一种数据结构
（2）队列中元素遵循“**先进先出**”(First In Last Out)原则，简称为**FIFO**结构，也称**先进先出表**。
（3）队列对外提供push、pop等统一的接口，内部可以选择链表、deque等数据结构实现（但注意不能用vector容器实现，因为数组不能实现pop操作）。由于底层容器的选择**不影响**队列的使用，且使用者可以自由选择使用何种结构实现队列，因而队列和栈一样具有**可插拔**的性质，在STL中同样被归类为“**容器适配器(container adapter)**”而不是容器。
~~~cpp
// 指定列表为底层容器的队列
std::queue<int, std::list<int>> exp;
~~~

### 2.队列的组成
（1）由于队列只允许对队头和队尾元素进行操作，不能进行遍历，所以不提供迭代器
（2）队头：位于队头的元素只能进行读取和出队操作
（3）队尾：新元素将被插入队尾

### 3.队列的基本操作
（1）进队(push) 在队尾插入一个元素
（2）出队(pop) 删除队列第一个元素
（3）(size) 返回队列中元素个数
（4）判断队列是否为空(empty) 如果队列空则返回true
（5）取队头(gethead) 返回队列中的第一个元素
（6）取队尾(getrear) 返回队列中最后一个元素
~~~cpp
bool empty()               // 判断空运算
void push(T elm)           // 进队列运算
void pop()                 // 出队列运算
int front()                // 取队头运算
int back()                 // 取队尾运算
int size()                 // 返回队列中元素个数 
~~~

## 二、队列的顺序存储结构
### 1.非循环队列
- 队空条件：front == rear
- 队满（队上溢出）条件：rear = MaxSize - 1
- 元素e进队操作：data[++rear] = e
- 出队操作：e = data[++front]

### 2.循环队列
为了克服非循环队列的**假溢出**（队列中有空位置但仍然满足队满条件的上溢出）现象，充分利用数组的空间，可以将data数组的前后端相连，形成循环数组
- 队空条件：rear == front
- 队满条件：(rear + 1)%MaxSize==front（相当于做一次试探进队，如果rear达到front说明队满了）
- 元素e进队操作：rear = (rear + 1)%MaxSize, data[rear] = e
- 元素e出队操作：e = data[front], front = (front + 1)%MaxSize 

## 三、队列的链式存储结构
- 队空条件：front == rear == NULL
- 队满条件：只在内存溢出时发生，基本不考虑
- 元素e进队操作：用尾插法将含e的节点插入链表
- 出队操作：读取首节点的值并将其删除


