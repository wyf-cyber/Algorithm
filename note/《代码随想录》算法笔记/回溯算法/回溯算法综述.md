# 回溯算法（Backtracking Algorithm）
## 一、算法简介
### （一）特性
回溯算法是一种常用于解决组合优化问题、搜索问题和决策问题的算法。事实上，回溯正是**递归**的副产物，回溯算法就是通过递归实现**深度优先搜索**的算法。他通过遍历所有情况来找到问题的解，若当前方案不可行，就会回溯（回退）并尝试其他可能的路径。和多层嵌套for循环相比，这种递归试错的方法不必设计**大量重复**的for循环，有效减轻了代码的复杂度，有利于算法在大规模的搜索空间中寻找最佳解决方案。
回溯算法的本质是**穷举**所有可能情况，虽然它的时间复杂度可能很高，但在许多复杂情况下，它仍然是一个可行的解决方案。除此以外，有效的剪枝操作也可以在一定程度上降低算法的时空复杂度。

### （二）应用领域
回溯算法常用于解决需要大规模遍历操作的问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

### （三）基本步骤
- 选择决策变量：确定问题中需要做出决策的变量，这些变量构成了解空间的一部分。
- 定义约束条件：确定哪些决策组合是合法的，排除非法解。
- 定义目标函数：如果是优化问题，定义要最大化或最小化的目标函数。
- 搜索解空间：通过深度优先搜索来遍历所有可能的解决方案，从一个决策点到下一个决策点，逐步构建解。
- 剪枝：在搜索过程中，根据约束条件和目标函数，排除不可能导致解的路径，以提高效率。
- 标记和取消标记：通常在搜索过程中需要标记已经访问过的决策点，以避免重复搜索，然后取消标记以回溯到之前的状态。
- 终止条件：定义何时算法应该终止，通常是找到一个解或搜索完整个解空间。
- 处理解：在找到解或搜索结束后，对解进行处理，可能输出、保存或进一步分析。

### （四）回溯算法模板
注：此处整理引用自[《代码随想录》](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
#### （1）回溯函数参数&返回值
- **返回值** ：回溯函数通常使用全局变量保存结果，因此返回值常设为void
- **参数** ：回溯函数根据题意需要较多的参数，不容易一步到位确定所有参数，因此往往先写逻辑，需要什么参数就添加到参数列表中去
~~~cpp
void backtracking(/*参数*/){
    // 函数逻辑
}
~~~
#### （2）回溯函数终止条件
和树的搜索相似，回溯算法通常在递归函数的最开始部分检查是否满足终止条件
- 搜索到叶子结点
- 找到目标组合
~~~cpp
if(/*终止条件*/) {
    // 将当前路径的记录添加到结果集合中
    return;
}
~~~
#### （3）回溯搜索的遍历过程
回溯法解决问题的过程可以被理解为使用递归对N叉树进行深度优先搜索的过程，因为回溯算法解决的问题都是在集合中寻找特定子集的问题，必须通过遍历穷举的方法才能解决。
- 集合的大小决定了树的**宽度**
- 递归的深度决定了树的**深度**
![Alt](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)
~~~cpp
for(/*选择本层集合中的元素逐一遍历（也可能存在剪枝）*/) {
    // 将本节点加入路径
    backtracking(/*子集合的选择列表*/);
    // 将本节点退出路径，准备遍历同层的下一个节点（回溯的核心体现）
}
~~~
#### （4）代码模板
~~~cpp
void backtracking(/*参数*/){
    if(/*终止条件*/) {
        // 将当前路径的记录添加到结果集合中
        return;
    }

    for(/*选择本层集合中的元素逐一遍历（也可能存在剪枝）*/) {
        // 将本节点加入路径
        backtracking(/*子集合的选择列表*/);
        // 将本节点退出路径，准备遍历同层的下一个节点（回溯的核心体现）
    }
}
~~~
