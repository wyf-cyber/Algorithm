# 贪心算法综述
## 一、算法简介
### （一）特性
贪心算法顾名思义就是每一次做选择时**贪婪地选择当前最优解**的算法，它的本质就是将问题划分成多个子选择问题，在每一次选择中选择局部最优解，从而达到“全局最优解”。显然，局部最优并不永远等于全局最优，所以贪心算法并不是一种完备的算法（不一定能够找到全局最优解）。
### （二）应用领域
- 序列问题
- 股票问题
- 两个维度权衡问题
- 区间问题
  
### （三）基本步骤
1. 将原问题拆解成多个子问题
2. 制定合适的价值选择标准（选择何种参数作为评判“最优”的标准）
3. 逐个求解每一个子问题的局部最优解
4. 将局部最优解累积成全局最优解

## 二、简单的贪心算法问题
### （一）分发饼干
[455.分发饼干（LeetCode）](https://leetcode.cn/problems/assign-cookies/description/)
**题目要求：**
>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例：**
>输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

**提示：**
>1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1

**解题思路：**
根据题意，有以下要点：
- 每一次分发饼干都要求饼干的尺寸大于等于小孩的胃口
- 大饼干既可以分给胃口大的孩子，也可以分给胃口小的孩子，小饼干只能分给胃口小的孩子
- 如果把大饼干分给胃口小的孩子，剩下的小饼干不能分给胃口大的孩子就会造成浪费
- 所以尽量将大饼干给胃口大的孩子，把小饼干分给胃口小的孩子才能尽可能充分地利用所有饼干，实现满足人数最大化

为了尽可能将大饼干分给胃口大的孩子，需要先将饼干数组和孩子数组进行排序，然后从后往前遍历孩子数组，把手中最大的饼干分给胃口最大且小于饼干尺寸的孩子。该算法只需要遍历一次孩子数组，时间复杂度为O(n)。
**代码示例：**
~~~cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(s.size() == 0) return 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        // 优先分配大的饼干给胃口大的孩子
        int cookie = s.size() - 1;
        for(int i = g.size() - 1; i >= 0; i--) {
            if(cookie < 0) return s.size();
            if(g[i] <= s[cookie]) {
                cookie--;
            }
        }
        return s.size() - cookie - 1;
    }
};
~~~

### （二）最大子数组的和
[53.最大子数组和（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)
**题目要求：**
>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

**示例：**
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**提示：**
>1 <= nums.length <= 105
-104 <= nums[i] <= 104

**解题思路：**
根据题意，有以下要点：
- 求子数组的最大和
- 子数组是原数组中的连续元素序列

看到求连续子序列的和，第一时间想到双指针暴力算法，但使用双指针调节子序列区间需要用到两重for循环，时间复杂度为O(n^2^)，题目中有一个特别大的用例，两层for循环很容易超时。

在本题中贪心算法的“贪心”体现在**如何及时更改子数组的左边界**上。为了实现最大子列和，需要进行sum += nums[i] 的操作，当sum小于0时，与其加上以前的序列还不如直接重新开始，贪婪地舍弃以往的记录重新开始也是贪心算法的体现。利用这种方法并不会妨碍sum取到最大值，因为这实际上是一种剪枝操作，剪去**和为负数的子序列**只是剪去了永远不可能成为答案的子序列。我们只需要建立一个变量记录sum取到的最大值即可。

**代码示例：**
~~~cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        // 注意要进行比较取值操作，初始化为最小值以免初值大于正确结果影响正确结果的记录
        int res = INT_MIN;
        for(int i = 0; i < nums.size(); i++) {
            if(sum < 0) 
                sum = nums[i];
            else
                sum += nums[i];
            res = sum > res ? sum : res;  
        }
        return res;
    }
};
~~~


### （三）摆动序列
[376.摆动序列（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)
**题目要求：**
>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
例如， [1, 7, 4, 9, 2, 5] 是一个摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

**示例：**
>输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

**提示：**
>1 <= nums.length <= 1000
0 <= nums[i] <= 1000

**解题思路：**
根据题意，可以提炼出以下要点：
 **（重要！！！）子序列可以从原序列中删除一些元素得到**，这说明两点：
1. 子序列中的元素在原数组中**可以不相邻**
2. 子序列中的元素的相对位置必须和原数组中保持一致

注意到本题可以通过删除特定节点扩大所求子集的大小，由于题目只求子序列的最大长度，实际上我们并不需要真的进行删除操作，只需要跳过不符合要求的节点，不将它们记入总数中即可（不对它们进行操作，相当于剪除）。为了判断本轮差值是否合规，需要创建一个变量记录上一次有效摆动是上升还是下降，再比较两者的符号
- 如果符号相反说明是有效摆动，将子串长加一（相当一将该节点加入子串）
- 如果相同说明不是有效摆动，不对本节点做任何操作，继续搜索下一个元素

在捋清整体思路以后还需要注意两个细节：

**细节一**：跳过操作需要考虑哪些情况？不同情况的解决办法是否相通？

跳过操作看似简单，其实需要考虑多种情况：
- case 1 平顶（平底）:[1, 2, 2, 2, 1] 这种情况下，我们不需要记录连续相等元素m的前一个元素x，因为相等的元素会将x与自己的相对大小关系通过自身的相等关系传递到下一个不同值的元素y处（在编程中，我们通过不修改 prevDiff 来实现保留）。当 m > x 且 m > y 时 m 构成高峰，x,y 构成谷底，一共计数3次即可
- case 2 连续上升（下降）:[1, 2, 3, 1] 这种情况看似有所变化实际上和第一种是一样的，递增（递减）的元素会将x与自己的相对大小关系通过**不等式的传递性**传递到下一个不同值的元素y处（在编程中，我们通过不修改 prevDiff 来实现保留）
- case 3 相等后继续上升（下降）:[1, 2, 2, 3, 1] 这是情况一和情况二的结合，首先按照情况一的方法剪去重复元素，数组变为[1, 2, 3, 1]，然后按照情况二的方法删去连续递增元素3，得到[1, 2, 1]
由此，我们可以看出虽然情况很多，但解决办法是相同的，确保检查到违规情况以后跳过不修改参数即可。

**细节二**：prevDiff的正负记录了上一轮合规元素比较的结果，那么它的起始状态是什么？

我们希望在初始时不考虑前一个元素与当前元素的差值。初始化为0可以确保在处理第一个元素时，不会意外地将其判断为连续递增或连续递减，导致第一个元素被剪除。

此外，初始化为0和其余部分的处理逻辑相吻合，可以避免为其制定额外的条件逻辑。我们在处理差值时，根据符号的改变来判断是否要增加 maxLength。具体地说，如果差值 diff 为正，且 prevDiff 为负或零，或者如果差值 diff 为负，且 prevDiff 为正或零，那么说明出现了摆动，此时应增加 maxLength。这种差值的符号改变是摆动子序列的关键标志。在这个过程中 prevDiff 初始化为 0 恰好可以保证第一个元素不被剪除。

**代码示例：**
~~~cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() < 2) {
            return nums.size();
        }

        int maxLength = 1;
        int prevDiff = 0;  // 用于跟踪前一个元素与当前元素的差值

        for (int i = 1; i < nums.size(); i++) {
            int diff = nums[i] - nums[i - 1];

            if ((diff > 0 && prevDiff <= 0) || (diff < 0 && prevDiff >= 0)) {
                maxLength++;
                prevDiff = diff;
            }
        }

        return maxLength;
    }
};
~~~
